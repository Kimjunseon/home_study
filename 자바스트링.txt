상속
1. 확장성
2. 재사용
-------------------------------------------------------------
추상메소드, 추상 클래스 조건
추상 클래스는 new를 붙힐 수 없다.
이유는 공통된 속성이 여러 객체에 적용할 떄 세부적인 구현이 불가함

포유류(움직인다(공통)) ---- 사람((공통), 2발로 걷기)
		   개((공통), 4발로 걷기)
		   고래((공통), 헤엄치다)

1조건 성립 포유류 m = new 사람()
2조건 성립 오버라이드, 다형성, 움직이다 한 개로 객체의 종류에 따라 여러가지로 해석
*오버라이드: 부모의 있는 구현을 다시 사용.. 부모가 아닌 자식이 불림
-------------------------------------------------------------
1. 클래스--- 변수, 메소드, 생성자
2. 정보은닉--- 캡슐화
3. 상속
4. 다형성 --- 오버로딩, 오버라이딩
5. 추상클래스--- 인터페이스
6. API
-------------------------------------------------------------
[클래스 변수]
접근자제어
접근자제어 범위
private
내부에서만 접근 가능 - 정보은닉
[private void setName] 메인에서 외부로 접근하려면 메소드를 세팅하기

protected
자식에서 접근이 가능 (부모에 protected 생성)

(디폴트)
같은 패키지에서만

public
제한없음

[클래스 메소드]
signiture => 파라미터의 개수, 타입, 순서가 같아야 시그니처가 같음

오버로딩
void m(int a, double d)
void m(int b, double d)
두개 다 다르므로 같은 클래쓰 내에서 사용 가능,,, 두 시그니쳐는 다름

오버라이딩
void m(int a, double d)
void m(int a, double d)
두개 다 같지만 부모와 자식에 각각으로 흩어져 있으면 생성이 가능
----------1026 메소드 내용 추가---------------------
call function by value 로 넘겨주면 변동이 없음(파라미터)


call function by reference  로 넘겨주면 변동이 있음(파라미터)


-------------------------------------------------------------
생성자
생성자: 객체의 초기화 담당
객체를 생성할 때
set or 생성자로 생성
오버로딩은 하나의 클래스에서만 일어난다. (클래스와 다형성)
--------------------------------------------------------------------
상속을 하는 이유
재사용성
최상위 클래스는 object



hash heap stack 오브젝트 객체 클래스 메소드 인스턴스 파라미터 도메인





